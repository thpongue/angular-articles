When working on an Angular project you may want to split your codebase up into seperate library projects for some of the following reasons:
- You need to reuse components across multiple projects
- Different elements are conceptually different and it helps to work on them seperately
- Some components are rarely changed so you want to remove them from the compilation and testing process that you run regularly

The options are:
private / public npm repository
- For rarely changed libraries a private or public npm library works fine. This is the main use case for npm. However, iterative development on these projects becomes tricky.

point npm to a local dependency - ie a local file reference within the dependencies
- This is relatively easy to do and npm accepts relative paths so you can share this between colleagues. It does, however, make the projcet setup a little more complex.
- In effect, you are requiring a sibling project in order for this project to succeed.
- For local dependencies which change a lot this will require that you're constantly updating the dependencies version number in the package.json on both sides which feels a bit fiddly.
- Without this your changes won't be picked up.

npm link
- This gets around the problem above of having to update version numbers. However, the relationship between the 2 projects is now not even in the package.json.
- link relies on creating a global package accessible by the recipient project.
- There are some clever things you can do with the preinstall hook in your npm scripts but we still have the same problem as we have with local file references where there is a sibling dependency.

monorepo
- Just chuck everything into one project. Accept that its all coupled. Use lots of npm scripting to be able to test each thing seperately and enjoy the convenience of quickly updating dependencies.

Summary
- None of these is perfect catch-all. For local dependencies of personal projects I tend to use npm link in order to avoid the admin of updating version numbers all the time.
- Monorepo's seem fashionable, and no doubt remove complexity but I would rather avoid.
